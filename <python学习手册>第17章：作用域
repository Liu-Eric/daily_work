1.4本地变量
所有在函数内被赋值的变量名都被认为是本地变量（包括在参数赋值时），本地变量仅在函数运行时存在并可见，在函数运行后消失。

1.5作用域
当在一个程序中使用变量名时，Python创建、改变或查找变量名都在所谓的命名空间中进行的，变量名在代码中被赋值的位置决定了这个变量名可以被访问的范围。
命名空间可以解决变量名冲突问题。
Python的变量名和作用域定义都是在Python赋值时候生成的，Python将一个变量名赋值的地点关联到一个特定的命名空间中。在代码中变量名赋值的位置决定了它属于哪个命名空间。
一个函数内部的变量名都是与函数的命名空间关联的。def内的变量只能在def内部代码使用，不能被def外部代码使用，def中的变量与def外的变量不互相干扰。
变量三种作用域：
def内部赋值属于函数作用域、def外部赋值属于全局作用域、一个嵌套在函数内def中的变量对于嵌套函数而言是nonlocal的。

1.6 作用域法则
一个文件顶层的变量名对于该文件内部代码而言是全局变量。
每一个函数的调用都创建了一个函数命名空间。
函数内部赋值变量都是本地的，除非使用global、nonlocal，修改对象不会改变对象作用域。
在一个函数中使用=、import、def、参数赋值等产生的变量都属于本地变量。

1.6 变量名解析：LEGB原则
变量名引用分四个作用域查找：本地、函数内（如果有的话）、全局、内置。
全局声明和非本地声明将赋值变量名映射到模块文件内部的作用域。
当在一个def外部赋值变量名时，本地作用域就是全局作用域。
LEGB:当函数代码使用一个函数名时，Python搜索4个作用域【本地作用域、上一层的def或lambda作用域、全局作用域、内置作用域】，并在第一次找到的地方停下来。
def内部代码改变上层变量（上层函数、全局）需要将变量名声明为global、nonlocal。

1.7 内置作用域
内置作用域主要用于包含Python内置函数和异常类。
内置作用域可以通过import __builtin__方法导入，但根据LEGB原则，内置变量不需要显示导入。
当内置变量名和其他变量存在命名冲突时，需要显示导入内置命名空间。

1.8 global语句
global语句是一个声明语句，表示接下来生成的变量是全局变量。全局变量在函数内可以直接饮用，被赋值的话必须global声明。
函数使用全局变量记录状态，在多线程中也使用全局变量作为不同函数间的共享内容，扮演了函数通信的角色。
最小化或者避免文件间的修改。

1.9作用域和嵌套函数
E的查找：在代码语法上嵌套了的函数作用域查找，由内之外。例：函数f1嵌套函数f2，f2可以使用f1中的变量。
如果变量在函数内声明为nonlocal，赋值会修改最近的嵌套函数的本地作用域。
工厂函数:功能函数外层嵌套一个状态函数，功能函数可以获取状态函数参数，返回功能函数，尽管此时状态函数已经退出，但保留状态函数参数。
def condition(n):
    def action(x):
        return x * n
    return action
lambda表达式引入了新的本地作用表达式，也可以在嵌套作用域中查找。
def func()
    x = 4
    action = (lambda n, x=x:x**n) #老版本Python不能使用嵌套作用域，需要赋值为默认参数
    return action 
如果lambda或者def在函数定义嵌套在一个循环内，同时引用了一个上层嵌套函数的变量，该变量在循环中被改变，所有在循环中产生的函数将指向同一个上层嵌套函数变量，因为嵌套作用域中的变量只有在函数给调用时才去查找，正确的方法是写成默认函数。
def makeactions():
    acts = []
    for i in range(5):
        acts.append(lambda x,i=i:i**x)
    return acts
