1.1 为何使用函数
最大化的代码重用和最小化的代码冗余
流程的分解
当函数调用时，调用者停止运行将控制权交给函数，直到函数完成它的工作，函数将调用权返回给调用者。

1.2 def语句
函数定义
def <func_name>(arg1, arg2, ..., argN):
    <statement>
    return <value>
    
def语句在运行时将创建一个函数对象（与其他对象类型一致），并将其赋给一个变量名，函数名仅仅是函数对象的引用，函数允许任意对象附加到函数属性上。
def func_name1():
    pass
func_name2 = func_name1
func_name2.attr = value

def语句是实时执行语句，可以出现在任何位置，包括while、if等嵌套结构中。
if condition：
    def func()
else:
    def func()
    
return语句返回函数结果，如果没有return语句，返回None。

1.3函数的多态
函数的操作意义取决于函数操作对象，如果函数的操作不支持操作对象，会抛出一个异常。
def times(x,y)
    return x * y
times(2,5)
times('Hello', 10)

1.4本地变量
所有在函数内被赋值的变量名都被认为是本地变量（包括在参数赋值时），本地变量仅在函数运行时存在并可见，在函数运行后消失。

1.5作用域
当在一个程序中使用变量名时，Python创建、改变或查找变量名都在所谓的命名空间中进行的，变量名在代码中被赋值的位置决定了这个变量名可以被访问的范围。
命名空间可以解决变量名冲突问题。
Python的变量名和作用域定义都是在Python赋值时候生成的，Python将一个变量名赋值的地点关联到一个特定的命名空间中。在代码中变量名赋值的位置决定了它属于哪个命名空间。
一个函数内部的变量名都是与函数的命名空间关联的。def内的变量只能在def内部代码使用，不能被def外部代码使用，def中的变量与def外的变量不互相干扰。
变量三种作用域：
def内部赋值属于函数作用域、def外部赋值属于全局作用域、一个嵌套在函数内def中的变量对于嵌套函数而言是nonlocal的。

1.6 作用域法则
一个文件顶层的变量名对于该文件内部代码而言是全局变量。
每一个函数的调用都创建了一个函数命名空间。
函数内部赋值变量都是本地的，除非使用global、nonlocal，修改对象不会改变对象作用域。
在一个函数中使用=、import、def、参数赋值等产生的变量都属于本地变量。

1.6 变量名解析：LEGB原则
变量名引用分四个作用域查找：本地、函数内（如果有的话）、全局、内置。
全局声明和非本地声明将赋值变量名映射到模块文件内部的作用域。
当在一个def外部赋值变量名时，本地作用域就是全局作用域。
LEGB:当函数代码使用一个函数名时，Python搜索4个作用域【本地作用域、上一层的def或lambda作用域、全局作用域、内置作用域】，并在第一次找到的地方停下来。
def内部代码改变上层变量（上层函数、全局）需要将变量名声明为global、nonlocal。

1.7 内置作用域
内置作用域主要用于包含Python内置函数和异常类。
内置作用域可以通过import __builtin__方法导入，但根据LEGB原则，内置变量不需要显示导入。
当内置变量名和其他变量存在命名冲突时，需要显示导入内置命名空间。

1.8 global语句
global语句是一个声明语句，表示接下来生成的变量是全局变量。全局变量在函数内可以直接饮用，被赋值的话必须global声明。
函数使用全局变量记录状态，在多线程中也使用全局变量作为不同函数间的共享内容，扮演了函数通信的角色。
最小化或者避免文件间的修改。

1.9作用域和嵌套函数
E的查找：在代码语法上嵌套了的函数作用域查找，由内之外。例：函数f1嵌套函数f2，f2可以使用f1中的变量。
如果变量在函数内声明为nonlocal，赋值会修改最近的嵌套函数的本地作用域。
工厂函数:功能函数外层嵌套一个状态函数，功能函数可以获取状态函数参数，返回功能函数，尽管此时状态函数已经退出，但保留状态函数参数。
def condition(n):
    def action(x):
        return x * n
    return action
lambda表达式引入了新的本地作用表达式，也可以在嵌套作用域中查找。
def func()
    x = 4
    action = (lambda n, x=x:x**n) #老版本Python不能使用嵌套作用域，需要赋值为默认参数
    return action 
如果lambda或者def在函数定义嵌套在一个循环内，同时引用了一个上层嵌套函数的变量，该变量在循环中被改变，所有在循环中产生的函数将指向同一个上层嵌套函数变量，因为嵌套作用域中的变量只有在函数给调用时才去查找，正确的方法是写成默认函数。
def makeactions():
    acts = []
    for i in range(5):
        acts.append(lambda x,i=i:i**x)
    return acts

2.0 nonlocal语句
nonlocal语句可以对外层嵌套函数中的名称进行读取和写入，nonlocal声明的变量必须已经存在（只能修改不能创建,global可以创建和修改），因为nonlocal的的查找范围从嵌套def开始，而不是声明函数本地开始，nonlocal只会嵌套def作用域中查找。
def tester(start):
    state =start
    def nested(label):
        nonlocal state
        print(label, state)
        state += 1
    return nested
可以使用带有运算符重载的类来替代nonlocal嵌套函数：
class tester:
    def __init__(self,state):
        self.state = state
    def __call__(sefl, label):
        print(label, self.state)
        self.state += 1
        
3.1 函数的参数传递
参数的传递是通过自动将对象赋值给本地变量名实现的，所有的参数实际上是通过指针进行传递的，作为参数被传递的对象从来不自动拷贝。
函数内部的参数名的赋值不影响调用者，因为是两个不同的作用域。
改变参数的可变对象值会对调用者产生影响。
函数的调用形式：
func(value), func(name=value), func(*sequence), func(**dict)
在函数的调用中，简单的通过变量名位置进行匹配，但是使用name=value的形式告诉python依照变量名进行匹配，这些叫关键字参数。在调用中使用*sequence或者**dict允许我们在一个序列或者字典中相应的封装任意多的位置位置相关或者关键字对象，并且在将他们传递给函数的时候，将他们解包为分开的单个的参数。
函数的定义形式：
def func(value), def func(name=value), def func(*name), def func(**name), def func(*args, name), def func(*, name=value)
在函数的头部，一个简单的变量名是通过位置或者变量名进行匹配的，但是name=value的形式定义了默认的参数值，*name的形式收集了任意的额外不匹配的参数到元组中，并且**name的形式收集了额外的关键字参数到字典中。在python3.0之后的版本，跟在*name或者一个单独的*之后的任何正式的或默认的参数名称，都是keyword-only参数，必须在调用时按照关键字传递。











###函数参数类型
位置参数，按传入位置赋值
默认参数必须是不可变类型，默认参数赋值时尽量按变量名赋值，避免位置混乱。
可变参数定义
def calc(*numbers):
    sum = 0
    for n in numbers:
        sum = sum + n * n
    return sum
传入元组/列表类型可变参数
>>> nums = [1, 2, 3] >>> calc(*nums)
关键字参数允许传入任意个含参数名的参数，这些关键字参数在函数内部自动组装为一个dict
def func(a,b,**kws):
    for key, value in kws:
        print(key, value)
关键字参数传入字典对象
>>> extra = {'city': 'Beijing', 'job': 'Engineer'} >> person('Jack', 24, **extra)
命名关键字参数数定义
def person(name, age, *, city, job):
命名关键字参数必须传入参数名
>>> person('Jack', 24, city='Beijing', job='Engineer')
命名关键字参数可以使用默认值
def person(name, age, *, city = 'beijing', job)
如果函数定义中已经有了一个可变参数，后面跟着的命名关键字参数就不再需要一个特殊分隔符*了
def person(name, age, *args, city, job):
参数组合
在Python中定义函数，可以用必选参数、默认参数、可变参数、关键字参数和命名关键字参数，这5种参数都可以组合使用。但是请注意，参数定义的顺序必须是：必选参数、默认参数、可变参数、命名关键字参数和关键字参数。
python函数收到的参数个数不对，或者参数类型不接受，会报出TypeError错误。
###递归函数
使用递归函数需要注意防止栈溢出。在计算机中，函数调用是通过栈（stack）这种数据结构实现的，每当进入一个函数调用，栈就会加一层栈帧，每当函数返回，栈就会减一层栈帧。由于栈的大小不是无限的，所以，递归调用的次数过多，会导致栈溢出。
RuntimeError: maximum recursion depth exceeded in comparison
解决递归调用栈溢出的方法是通过尾递归优化,尾递归是指，在函数返回的时候，调用自身本身，并且，return语句不能包含表达式。这样，编译器或者解释器就可以把尾递归做优化，使递归本身无论调用多少次，都只占用一个栈帧，不会出现栈溢出的情况。
def fact_iter(num, product):
    if num == 1:
        return product
    return fact_iter(num - 1, num * product)
遗憾的是Python解释器也没有做优化，所以，即使把上面的递归函数改成尾递归方式，也会导致栈溢出。
###高阶函数
函数名本身就是变量
高阶函数定义：一个函数接收另一个函数名作为参数。
def add(x, y, f):
    return f(x) + f(y)
map()函数接收两个参数，一个是函数对象，一个是Iterable对象，map将传入的函数依次作用到序列的每个元素，并把结果作为新的Iterator返回。
Iterator对象是惰性序列，可以通过list()函数让它把整个序列都计算出来并返回一个list。
reduce()函数接收两个参数，一个是函数对象，一个是Iterable对象，把一个作用在Iterator上。
filter()函数接收一个函数对象和一个序列对象，filter()把传入的函数依次作用于每个元素，然后根据返回值是True还是False决定保留还是丢弃该元素。
filter()函数返回的是一个Iterator。
sorted()函数也是一个高阶函数，它可以接收一个key函数来实现自定义的排序。
>>> sorted([36, 5, -12, 9, -21], key=abs, reverse=True)
###函数返回函数
高阶函数可以把函数作为结果值返回
def lazy_sum(*args):
    def sum():
        ax = 0
        for n in args:
            ax = ax + n
        return ax
    return sum
当我们调用lazy_sum()时，返回的并不是求和结果，而是求和函数：
>>> f = lazy_sum(1, 3, 5, 7, 9)
>>> f
<function lazy_sum.<locals>.sum at 0x101c6ed90>
调用函数f时，才真正计算求和的结果：
>>> f()
25
这种将相关参数和函数变量都保存在返回的函数中的数据结构称为“闭包”。
###匿名函数
f = lambda x: x * x
###装饰器
在代码运行期间对函数动态增加功能的方式，称之为“装饰器”（Decorator），本质上，decorator就是一个返回函数的高阶函数。
定义装饰器：
def log(func):
    def wrapper(*args, **kw):
        print('call %s():' % func.__name__)
        return func(*args, **kw)
    return wrapper
使用装饰器
@log
def func():
把@log放到now()函数的定义处，相当于执行了语句：now = log(now)
###偏函数
总结functools.partial的作用就是，把一个函数的某些参数设置默认值（仍然可以显式传入），返回一个新的函数，调用这个新函数会更简
int2 = functools.partial(int, base=2)

