###函数定义
def <name>(arg1, arg2, ..., argN):
    <statement>
    return <value>
def语句在运行时将创建一个函数对象并将其赋给一个变量名，函数体内部代码在执行函数时调用。
###函数参数类型
位置参数，按传入位置赋值
默认参数必须是不可变类型，默认参数赋值时尽量按变量名赋值，避免位置混乱。
可变参数定义
def calc(*numbers):
    sum = 0
    for n in numbers:
        sum = sum + n * n
    return sum
传入元组/列表类型可变参数
>>> nums = [1, 2, 3] >>> calc(*nums)
关键字参数允许传入任意个含参数名的参数，这些关键字参数在函数内部自动组装为一个dict
def func(a,b,**kws):
    for key, value in kws:
        print(key, value)
关键字参数传入字典对象
>>> extra = {'city': 'Beijing', 'job': 'Engineer'} >> person('Jack', 24, **extra)
命名关键字参数数定义
def person(name, age, *, city, job):
命名关键字参数必须传入参数名
>>> person('Jack', 24, city='Beijing', job='Engineer')
命名关键字参数可以使用默认值
def person(name, age, *, city = 'beijing', job)
如果函数定义中已经有了一个可变参数，后面跟着的命名关键字参数就不再需要一个特殊分隔符*了
def person(name, age, *args, city, job):
参数组合
在Python中定义函数，可以用必选参数、默认参数、可变参数、关键字参数和命名关键字参数，这5种参数都可以组合使用。但是请注意，参数定义的顺序必须是：必选参数、默认参数、可变参数、命名关键字参数和关键字参数。
python函数收到的参数个数不对，或者参数类型不接受，会报出TypeError错误。
###递归函数
使用递归函数需要注意防止栈溢出。在计算机中，函数调用是通过栈（stack）这种数据结构实现的，每当进入一个函数调用，栈就会加一层栈帧，每当函数返回，栈就会减一层栈帧。由于栈的大小不是无限的，所以，递归调用的次数过多，会导致栈溢出。
RuntimeError: maximum recursion depth exceeded in comparison
解决递归调用栈溢出的方法是通过尾递归优化,尾递归是指，在函数返回的时候，调用自身本身，并且，return语句不能包含表达式。这样，编译器或者解释器就可以把尾递归做优化，使递归本身无论调用多少次，都只占用一个栈帧，不会出现栈溢出的情况。
def fact_iter(num, product):
    if num == 1:
        return product
    return fact_iter(num - 1, num * product)
遗憾的是Python解释器也没有做优化，所以，即使把上面的递归函数改成尾递归方式，也会导致栈溢出。
###高阶函数
函数名本身就是变量
高阶函数定义：一个函数接收另一个函数名作为参数。
def add(x, y, f):
    return f(x) + f(y)
map()函数接收两个参数，一个是函数对象，一个是Iterable对象，map将传入的函数依次作用到序列的每个元素，并把结果作为新的Iterator返回。
Iterator对象是惰性序列，可以通过list()函数让它把整个序列都计算出来并返回一个list。
reduce()函数接收两个参数，一个是函数对象，一个是Iterable对象，把一个作用在Iterator上。
filter()函数接收一个函数对象和一个序列对象，filter()把传入的函数依次作用于每个元素，然后根据返回值是True还是False决定保留还是丢弃该元素。
filter()函数返回的是一个Iterator。
sorted()函数也是一个高阶函数，它可以接收一个key函数来实现自定义的排序。
>>> sorted([36, 5, -12, 9, -21], key=abs, reverse=True)






